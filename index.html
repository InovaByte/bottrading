<html><head><base href="https://www.binance.com/"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Bot de Sinais de Trading Binance Futures - EMA, RSI e Volume</title><style>
body {
  font-family: Arial, sans-serif;
  background-color: #f0f2f5;
  margin: 0;
  padding: 20px;
  color: #333;
}
.container {
  max-width: 1000px;
  margin: 0 auto;
  background-color: #fff;
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 0 10px rgba(0,0,0,0.1);
}
h1 {
  color: #f0b90b;
  text-align: center;
}
.chart-container {
  display: flex;
  justify-content: space-between;
  margin-bottom: 20px;
}
.chart {
  width: 48%;
  height: 300px;
}
.controls {
  display: flex;
  justify-content: space-between;
  margin-bottom: 20px;
}
button, select {
  background-color: #f0b90b;
  border: none;
  color: white;
  padding: 10px 20px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 16px;
  margin: 4px 2px;
  cursor: pointer;
  border-radius: 4px;
}
select {
  background-color: white;
  color: #333;
  border: 1px solid #f0b90b;
}
.stats {
  display: flex;
  justify-content: space-between;
  background-color: #f8f9fa;
  padding: 10px;
  border-radius: 4px;
  margin-bottom: 20px;
}
.stat {
  text-align: center;
}
.stat-value {
  font-size: 24px;
  font-weight: bold;
  color: #f0b90b;
}
#log {
  margin-top: 20px;
  height: 200px;
  overflow-y: auto;
  border: 1px solid #ddd;
  padding: 10px;
  font-family: monospace;
}
#signals {
  margin-top: 20px;
  border: 1px solid #ddd;
  padding: 10px;
  border-radius: 4px;
}
.signal {
  margin-bottom: 10px;
  padding: 10px;
  border-radius: 4px;
}
.signal.buy {
  background-color: #d4edda;
  color: #155724;
}
.signal.sell {
  background-color: #f8d7da;
  color: #721c24;
}
</style>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <div class="container">
    <h1>Bot de Sinais de Trading Binance Futures - EMA, RSI e Volume</h1>
    <div class="controls">
      <select id="symbolSelect">
        <option value="BTCUSDT">BTCUSDT</option>
        <option value="ETHUSDT">ETHUSDT</option>
        <option value="BNBUSDT">BNBUSDT</option>
        <option value="ADAUSDT">ADAUSDT</option>
        <option value="DOGEUSDT">DOGEUSDT</option>
        <option value="YGGUSDT">YGGUSDT</option>
        <option value="1000SHIBUSDT">1000SHIBUSDT</option>
      </select>
      <button id="startBtn">Iniciar Bot</button>
      <button id="stopBtn">Parar Bot</button>
    </div>
    <div class="chart-container">
      <div class="chart">
        <canvas id="priceChart"></canvas>
      </div>
      <div class="chart">
        <canvas id="indicatorChart"></canvas>
      </div>
    </div>
    <div class="stats">
      <div class="stat">
        <div>Sinais Gerados</div>
        <div id="signalsCount" class="stat-value">0</div>
      </div>
      <div class="stat">
        <div>Último Preço</div>
        <div id="lastPrice" class="stat-value">0 USDT</div>
      </div>
      <div class="stat">
        <div>EMA 50</div>
        <div id="ema50" class="stat-value">0</div>
      </div>
      <div class="stat">
        <div>EMA 200</div>
        <div id="ema200" class="stat-value">0</div>
      </div>
      <div class="stat">
        <div>RSI</div>
        <div id="rsi" class="stat-value">0</div>
      </div>
    </div>
    <div id="signals"></div>
    <div id="log"></div>
  </div>

<script>
// Configurações
let symbol = 'BTCUSDT';
const interval = '15m';
const leverage = 20;

// Variáveis globais
let isRunning = false;
let ws;
let priceChart;
let indicatorChart;
let signalsCount = 0;
let prices = [];
let volumes = [];
let ema50 = [];
let ema200 = [];
let rsiValues = [];

// Função para inicializar os gráficos
function initCharts() {
  const priceCtx = document.getElementById('priceChart').getContext('2d');
  priceChart = new Chart(priceCtx, {
    type: 'line',
    data: {
      labels: [],
      datasets: [{
        label: 'Preço',
        data: [],
        borderColor: 'rgb(75, 192, 192)',
        tension: 0.1
      }, {
        label: 'EMA 50',
        data: [],
        borderColor: 'rgb(255, 99, 132)',
        tension: 0.1
      }, {
        label: 'EMA 200',
        data: [],
        borderColor: 'rgb(54, 162, 235)',
        tension: 0.1
      }]
    },
    options: {
      responsive: true,
      scales: {
        x: {
          display: false
        },
        y: {
          beginAtZero: false
        }
      }
    }
  });

  const indicatorCtx = document.getElementById('indicatorChart').getContext('2d');
  indicatorChart = new Chart(indicatorCtx, {
    type: 'line',
    data: {
      labels: [],
      datasets: [{
        label: 'RSI',
        data: [],
        borderColor: 'rgb(255, 159, 64)',
        tension: 0.1
      }, {
        label: 'Volume',
        data: [],
        type: 'bar',
        backgroundColor: 'rgba(75, 192, 192, 0.2)',
        borderColor: 'rgb(75, 192, 192)',
        borderWidth: 1
      }]
    },
    options: {
      responsive: true,
      scales: {
        x: {
          display: false
        },
        y: {
          beginAtZero: true
        }
      }
    }
  });
}

// Função para atualizar os gráficos
function updateCharts() {
  if (prices.length > 100) {
    prices = prices.slice(-100);
    volumes = volumes.slice(-100);
    ema50 = ema50.slice(-100);
    ema200 = ema200.slice(-100);
    rsiValues = rsiValues.slice(-100);
  }

  priceChart.data.labels = Array(prices.length).fill('');
  priceChart.data.datasets[0].data = prices;
  priceChart.data.datasets[1].data = ema50;
  priceChart.data.datasets[2].data = ema200;

  indicatorChart.data.labels = Array(prices.length).fill('');
  indicatorChart.data.datasets[0].data = rsiValues;
  indicatorChart.data.datasets[1].data = volumes;

  priceChart.update();
  indicatorChart.update();
}

// Função para calcular EMA
function calculateEMA(data, period) {
  const k = 2 / (period + 1);
  let ema = data[0];
  const emaData = [ema];

  for (let i = 1; i < data.length; i++) {
    ema = (data[i] * k) + (ema * (1 - k));
    emaData.push(ema);
  }

  return emaData;
}

// Função para calcular RSI
function calculateRSI(data, period = 14) {
  const changes = data.slice(1).map((value, index) => value - data[index]);
  const gains = changes.map(change => change > 0 ? change : 0);
  const losses = changes.map(change => change < 0 ? -change : 0);

  let avgGain = gains.slice(0, period).reduce((sum, gain) => sum + gain, 0) / period;
  let avgLoss = losses.slice(0, period).reduce((sum, loss) => sum + loss, 0) / period;

  const rsiData = [];
  for (let i = period; i < data.length; i++) {
    const rs = avgGain / avgLoss;
    const rsi = 100 - (100 / (1 + rs));
    rsiData.push(rsi);

    // Atualizar médias móveis
    avgGain = ((avgGain * (period - 1)) + gains[i]) / period;
    avgLoss = ((avgLoss * (period - 1)) + losses[i]) / period;
  }

  return rsiData;
}

// Função para gerar sinal de trading
function generateSignal() {
  const lastPrice = prices[prices.length - 1];
  const lastEMA50 = ema50[ema50.length - 1];
  const lastEMA200 = ema200[ema200.length - 1];
  const lastRSI = rsiValues[rsiValues.length - 1];
  const lastVolume = volumes[volumes.length - 1];
  const prevVolume = volumes[volumes.length - 2];

  if (ema50[ema50.length - 2] <= ema200[ema200.length - 2] && lastEMA50 > lastEMA200 && lastRSI >= 30 && lastRSI <= 50 && lastVolume > prevVolume) {
    return 'buy';
  } else if (ema50[ema50.length - 2] >= ema200[ema200.length - 2] && lastEMA50 < lastEMA200 && lastRSI >= 50 && lastRSI <= 70 && lastVolume <= prevVolume) {
    return 'sell';
  }

  return null;
}

// Função para exibir sinal
function displaySignal(signal, price) {
  const signalsElement = document.getElementById('signals');
  const signalElement = document.createElement('div');
  signalElement.classList.add('signal', signal);
  signalElement.innerHTML = `
    <strong>${signal.toUpperCase()}</strong> ${symbol} @ ${price} USDT
    <br>
    Data: ${new Date().toLocaleString()}
    <br>
    EMA50: ${ema50[ema50.length - 1].toFixed(2)}
    <br>
    EMA200: ${ema200[ema200.length - 1].toFixed(2)}
    <br>
    RSI: ${rsiValues[rsiValues.length - 1].toFixed(2)}
    <br>
    Volume: ${volumes[volumes.length - 1].toFixed(2)}
  `;
  signalsElement.insertBefore(signalElement, signalsElement.firstChild);
  
  // Limitar o número de sinais exibidos
  if (signalsElement.children.length > 5) {
    signalsElement.removeChild(signalsElement.lastChild);
  }
  
  signalsCount++;
  document.getElementById('signalsCount').textContent = signalsCount;
}

// Função para logar mensagens
function log(message) {
  const logElement = document.getElementById('log');
  logElement.innerHTML += `${new Date().toLocaleTimeString()} - ${message}<br>`;
  logElement.scrollTop = logElement.scrollHeight;
}

// Função principal do bot
async function runBot() {
  if (!isRunning) return;

  try {
    // Update the API endpoint to use Binance Futures API
    const response = await fetch(`https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=300`);
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    const data = await response.json();
    prices = data.map(candle => parseFloat(candle[4])); // Preço de fechamento
    volumes = data.map(candle => parseFloat(candle[5])); // Volume

    ema50 = calculateEMA(prices, 50);
    ema200 = calculateEMA(prices, 200);
    rsiValues = calculateRSI(prices);

    updateCharts();

    // Iniciar WebSocket para receber atualizações de preço em tempo real
    if (ws) {
      ws.close();
    }
    ws = new WebSocket(`wss://fstream.binance.com/ws/${symbol.toLowerCase()}@kline_${interval}`);

    ws.onmessage = normalWebSocketHandler;

    ws.onerror = (error) => {
      log(`Erro no WebSocket: ${error.message}`);
      isRunning = false;
    };

    ws.onclose = () => {
      log('Conexão WebSocket fechada');
      isRunning = false;
    };

  } catch (error) {
    log(`Erro ao buscar dados históricos: ${error.message}`);
    log('Tentando inicializar com dados do WebSocket...');
    
    // Fallback: Initialize with WebSocket data
    initializeWithWebSocket();
  }
}

// Add a new function to initialize with WebSocket data
function initializeWithWebSocket() {
  prices = [];
  volumes = [];
  ema50 = [];
  ema200 = [];
  rsiValues = [];

  if (ws) {
    ws.close();
  }
  ws = new WebSocket(`wss://fstream.binance.com/ws/${symbol.toLowerCase()}@kline_${interval}`);

  ws.onmessage = (event) => {
    const message = JSON.parse(event.data);
    const price = parseFloat(message.k.c);
    const volume = parseFloat(message.k.v);

    prices.push(price);
    volumes.push(volume);

    if (prices.length >= 200) {
      ema50 = calculateEMA(prices, 50);
      ema200 = calculateEMA(prices, 200);
      rsiValues = calculateRSI(prices);
      updateCharts();
      log('Dados iniciais coletados. Iniciando operação normal do bot.');
      ws.onmessage = normalWebSocketHandler;
    }
  };

  ws.onerror = (error) => {
    log(`Erro no WebSocket: ${error.message}`);
    isRunning = false;
  };

  ws.onclose = () => {
    log('Conexão WebSocket fechada');
    isRunning = false;
  };
}

// Create a normal WebSocket handler function
function normalWebSocketHandler(event) {
  const message = JSON.parse(event.data);
  const price = parseFloat(message.k.c);
  const volume = parseFloat(message.k.v);

  prices.push(price);
  volumes.push(volume);

  ema50.push(calculateEMA(prices.slice(-50), 50).pop());
  ema200.push(calculateEMA(prices.slice(-200), 200).pop());
  rsiValues.push(calculateRSI(prices.slice(-15)).pop());

  updateCharts();

  document.getElementById('lastPrice').textContent = `${price} USDT`;
  document.getElementById('ema50').textContent = ema50[ema50.length - 1].toFixed(2);
  document.getElementById('ema200').textContent = ema200[ema200.length - 1].toFixed(2);
  document.getElementById('rsi').textContent = rsiValues[rsiValues.length - 1].toFixed(2);

  const signal = generateSignal();
  if (signal) {
    displaySignal(signal, price);
    log(`Sinal gerado: ${signal.toUpperCase()} ${symbol} @ ${price} USDT`);
  }
}

// Função para resetar o bot
function resetBot() {
  if (ws) {
    ws.close();
  }
  signalsCount = 0;
  document.getElementById('signalsCount').textContent = signalsCount;
  document.getElementById('lastPrice').textContent = '0 USDT';
  document.getElementById('ema50').textContent = '0';
  document.getElementById('ema200').textContent = '0';
  document.getElementById('rsi').textContent = '0';
  prices = [];
  volumes = [];
  ema50 = [];
  ema200 = [];
  rsiValues = [];
  updateCharts();
  document.getElementById('signals').innerHTML = '';
  document.getElementById('log').innerHTML = '';
}

// Event listeners
document.getElementById('startBtn').addEventListener('click', () => {
  if (!isRunning) {
    isRunning = true;
    log('Iniciando bot...');
    runBot();
  }
});

document.getElementById('stopBtn').addEventListener('click', () => {
  if (isRunning) {
    isRunning = false;
    if (ws) ws.close();
    log('Parando bot...');
  }
});

document.getElementById('symbolSelect').addEventListener('change', (event) => {
  symbol = event.target.value;
  resetBot();
  log(`Símbolo alterado para ${symbol}`);
});

// Inicialização
initCharts();
</script>
</body></html>
